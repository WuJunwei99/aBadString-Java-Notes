- [1 Java 简介](#1-java-简介)
	- [1.1 Java语言版本迭代](#11-java语言版本迭代)
	- [1.2 JDK JRE JVM 三者间的关系](#12-jdk-jre-jvm-三者间的关系)
	- [1.3 Hello World 程序](#13-hello-world-程序)
	- [1.4 注释](#14-注释)
- [2 变量](#2-变量)
	- [2.1 变量的声明和赋值](#21-变量的声明和赋值)
	- [2.2 Java 变量的分类](#22-java-变量的分类)
		- [2.2.1 按数据类型分](#221-按数据类型分)
		- [2.3.2 按声明位置分](#232-按声明位置分)
	- [2.3 变量间的运算](#23-变量间的运算)
		- [2.3.1 基本数据类型间的运算（不包括boolean）](#231-基本数据类型间的运算不包括boolean)
		- [2.3.2 基本数据类型和String间的运算](#232-基本数据类型和string间的运算)

# 1 Java 简介

## 1.1 Java语言版本迭代

1995年发布JDK1.0；JDK1.5开始改名为JDK5.0,以后都是6.0，7.0 …。

JavaSE（J2SE）：Java核心API + 桌面级应用开发

JavaEE（J2EE）：企业级开发（Web应用）

JavaME（J2ME）：移动端应用开发

## 1.2 JDK JRE JVM 三者间的关系

JDK = JRE + Java开发工具集

JRE = JVM + Java SE 标准类库

## 1.3 Hello World 程序

(1) **创建**：创建一个以.java结尾的文件

(2) **编辑**：

``` java  
public class HelloWorld {    
    public  static void main(String[] args) {        
        System.out.println("hello, world");    
    }  
} 
```

(3) **编译**：javac 源文件名.Java     可以生成一个或多个字节码文件（有几个类就有几个字节码文件）

(4) **运行**：java 字节码文件名（注意：不要.class拓展名）

说明：

1. 一个源文件中可以由多个类，但是只能有一个public类；

2. public类的名字必须和源文件名一样

## 1.4 注释

(1) **单行注释**：//

(2) **多行注释**：/* */

​    多行注释不能被嵌套使用

(3) **文档注释**：/** */

javadoc -d 目标路径 -author -version 源文件名.java



# 2 变量

## 2.1 变量的声明和赋值

第一种：声明变量，同时赋值

```java
// 一个变量  
int a = 1;  
// 多个变量  
int a = 1, b = 2, c = 3;  
```

第二种：先声明后赋值

```java
// 一个变量  
int a;  
a = 2;  
// 多个变量  
int a, b, c;  
a = b = c = 10;  
```

说明：

1.  变量的作用域：声明变量所在的那对大括号内；

2.  在同一个作用域内，变量命不允许重复；

3.  变量应该先声明后使用；

4.  同一个变量可以被多次赋值，后一次赋值覆盖前一次赋值。

## 2.2 Java 变量的分类

### 2.2.1 按数据类型分

(1) 整数类型：byte、short、int、long

​	Java的整数类型有固定的表数范围和字段长度，不受具体的操作系统的影响，以保证Java程序的可移植性。

​	Java整型常量默认为int类型，long类型常量必须在末尾加上“l”或者“L”。

| **类型** | **占用的存储空间** | **表数范围**             |
| -------- | ------------------ | ------------------------ |
| byte     | 1字节              | -128 ~ 127               |
| short    | 2字节              | -32768 ~ 32767           |
| int      | 4字节              | -2147483648 ~ 2147483647 |
| long     | 8字节              | -2^63  ~ 2^63-1          |

(2) 浮点类型：float、double

​	Java的浮点类型有固定的表数范围和字段长度，不受具体的操作系统的影响，以保证Java程序的可移植性。

​	Java浮点型常量默认为double类型（也可以在末尾加上“d”或者“D”），float类型常量必须在末尾加上“f”或者“F”。

​	浮点数表示形式：

​		十进制数表示法：5.12，512.0f，.512

​		科学计数表示法：5.12e2，512E2，100E-2

| **类型** | **占用的存储空间** | **表数范围**           |
| -------- | ------------------ | ---------------------- |
| float    | 4字节              | -3.403E38 ~ 3.403E38   |
| double   | 8字节              | -1.798E308 ~ 1.798E308 |

(3) 字符类型：char 

​	Java中的字符类型是占两个字节的。其表示方式有以下三种：

```java
// 单个普通字符  
char c1 = 'A';
char c2 = '中'; 
// 转义字符  
char n1 = '\n';  
// 3. Unicode值  
char n2 = '\u0056';
char c3 = 65;  
```

| 转义字符 | 意义                                | ASCII码值（十进制） |
| -------- | ----------------------------------- | ------------------- |
| \a       | 响铃(BEL)                           | 007                 |
| \b       | 退格(BS) ，将当前位置移到前一列     | 008                 |
| \f       | 换页(FF)，将当前位置移到下页开头    | 012                 |
| \n       | 换行(LF) ，将当前位置移到下一行开头 | 010                 |
| \r       | 回车(CR) ，将当前位置移到本行开头   | 013                 |
| \t       | 水平制表(HT) （跳到下一个TAB位置）  | 009                 |
| \v       | 垂直制表(VT)                        | 011                 |
| \\       | 代表一个反斜线字符''\'              | 092                 |
| \'       | 代表一个单引号（撇号）字符          | 039                 |
| \"       | 代表一个双引号字符                  | 034                 |
| \?       | 代表一个问号                        | 063                 |
| \0       | 空字符(NUL)                         | 000                 |
| \ddd     | 1到3位八进制数所代表的任意字符      | 三位八进制          |
| \xhh     | 十六进制所代表的任意字符            | 十六进制            |

**拓展:Unicode编码与UTF-8**

**UTF-8** **是 Unicode 的实现方式之一。**

UTF-8 的编码规则很简单，只有二条：

(1) 对于单字节的符号，字节的第一位设为0，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。

(2) 对于n字节的符号（n > 1），第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。

![image-20200319153726395](images/image-20200319153726395.png) 

跟据上表，解读 UTF-8 编码非常简单。如果一个字节的第一位是0，则这个字节单独就是一个字符；如果第一位是1，则连续有多少个1，就表示当前字符占用多少个字节。

引用自: http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html

(4) 布尔类型

只有true和false两个值。

(5)  各类型所占字节数

```java
/**
输出Java中基本类型所占字节数
版权声明：本文为CSDN博主「阳光岛主」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/ithomer/article/details/7310008
*/
public class CalSize {
    public static void main(String[] args) {
		System.out.println("int:\t" + Integer.SIZE/8);      // 4
		System.out.println("short:\t" + Short.SIZE/8);      // 2	
		System.out.println("long:\t" + Long.SIZE/8);	    // 8
		System.out.println("byte:\t" + Byte.SIZE/8);        // 1
		System.out.println("char:\t" + Character.SIZE/8);   // 2
		System.out.println("float:\t" + Float.SIZE/8);      // 4
		System.out.println("double:\t" + Double.SIZE/8);    // 8
		//System.out.println("Boolean: " + Boolean);
    }
}
```

![image-20200319153805485](images/image-20200319153805485.png) 

### 2.3.2 按声明位置分

（1）成员变量

（2）局部变量

![image-20200319154014930](images/image-20200319154014930.png) 

## 2.3 变量间的运算

### 2.3.1 基本数据类型间的运算（不包括boolean）

**(1) 自动类型提升**

自动类型提升：小容量的变量与大容量的变量做运算，结果用大容量的变量来接收。

byte，short，char --> int --> long --> float --> double

注意：

1、容量指的是表数范围，而不是所占存储空间。float（4字节）的表数范围大于long（8字节）。

​       2、byte，short，char三者之间的运算都会自动提升为int类型。

![image-20200319154117223](images/image-20200319154117223.png) 

**这是字段类型提升的一个坑：**

自动类型提升有好处，但它也会引起令人疑惑的编译错误。例如，下面看起来正确的程序却会引起问题：

```java
byte b = 50;
b = b * 2;    // Type mismatch: cannot convert from int to byte
```

如上所示，第二行会报“类型不匹配：无法从int转换为byte”错误。

![image-20200319154221155](images/image-20200319154221155.png) 

该程序试图将一个完全合法的 byte 型的值 50*2 再存储给一个 byte 型的变量。但是当表达式求值的时候，操作数被自动的提升为 int 型，计算结果也被提升为 int 型。这样表达式的结果现在是 int 型，不强制转换它就不能被赋为 byte 型。确实如此，在这个特别的情况下，被赋的值将仍然适合目标类型。

所以应该使用一个显示的强制类型转换，例如：

```java
byte b = 50;
b = (byte)(b * 2);
```

这样就能产生正确的值 100。

注意：char 类型比较特殊，char 自动转换成 int、long、float 和 double，但 byte 和 short 不能自动转换为 char，而且 char 也不能自动转换为 byte 或 short。

引用自：http://c.biancheng.net/view/796.html

**这是另一个坑**

float和long运算，会自动类型提升为float。例如如下代码编译错误：

```java
long l = 200L;
float f = 10.0F;
long r = l + f;
```

![image-20200319154315289](images/image-20200319154315289.png) 

需要使用float类型变量来存储运算结果。

```java
long l = 200L;
float f = 10.0F;
float r = l + f;
```

**(2) 强制类型转换：自动类型提升的逆过程。**

格式：目标类型 变量 = (目标类型)源类型变量/常量

注意：

​	1、使用强制类型转换运算符号“(类型)”。

​	2、可能会损失精度或者类型溢出。

​	3、在强制类型转换中目标类型和源类型变量的类型始终没有发生改变。

### 2.3.2 基本数据类型和String间的运算

​	1、 字符串和基本数据类型之间只能做连接运算，没有自动类型提升。

​	2、 字符串做链接运算的结果是字符串类型，只能用字符串来接受

​	3、 注意“+”号是做加法，还是做字符串连接符。