- [1 Java 内存区域](#1-java-内存区域)
    - [1.1 JVM 运行时数据区](#11-jvm-运行时数据区)
        - [1.1.1 程序计数器 Program Counter Register](#111-程序计数器-program-counter-register)
        - [1.1.2 虚拟机栈 Java Virtual Machine Stacks](#112-虚拟机栈-java-virtual-machine-stacks)
        - [1.1.3 本地方法栈 Native Method Stacks](#113-本地方法栈-native-method-stacks)
        - [1.1.4 堆 Heap](#114-堆-heap)
        - [1.1.5 方法区 Method Area](#115-方法区-method-area)
        - [1.1.6 运行时常量池](#116-运行时常量池)
    - [1.2 对象访问](#12-对象访问)
- [2 垃圾回收机制 GC](#2-垃圾回收机制-gc)
    - [2.1 如何判断对象已死](#21-如何判断对象已死)
        - [2.1.1 引用计数法 Reference Counting（Java 并不是）](#211-引用计数法-reference-countingjava-并不是)
        - [2.1.2 根搜索算法 GC Roots Tracing](#212-根搜索算法-gc-roots-tracing)
    - [2.2 引用](#22-引用)
        - [2.2.1 强引用](#221-强引用)
        - [2.2.2 软引用](#222-软引用)
        - [2.2.3 弱引用](#223-弱引用)
        - [2.2.4 虚引用](#224-虚引用)
    - [2.3 GC 是如何回收对象](#23-gc-是如何回收对象)
        - [2.3.1 finalize()方法](#231-finalize方法)
        - [2.3.2 方法区垃圾回收](#232-方法区垃圾回收)
    - [2.4 垃圾收集算法](#24-垃圾收集算法)
        - [2.4.1 标记 — 清除算法](#241-标记--清除算法)
        - [2.4.2 复制算法](#242-复制算法)
        - [2.4.3 标记 — 整理算法](#243-标记--整理算法)
        - [2.4.4 分代收集算法](#244-分代收集算法)
    - [2.5 垃圾收集器](#25-垃圾收集器)
        - [2.5.1 Serial](#251-serial)
        - [2.5.2 ParNew](#252-parnew)
        - [2.5.3 Parallel Scavenge](#253-parallel-scavenge)
        - [2.5.4 Serial Old](#254-serial-old)
        - [2.5.5 Parallel Old](#255-parallel-old)
        - [2.5.6 CMS](#256-cms)
        - [2.5.7 G1](#257-g1)
    - [2.6 内存分配策略](#26-内存分配策略)
- [3 类文件结构](#3-类文件结构)
    - [3.1 Class 类文件结构](#31-class-类文件结构)

# 1 Java 内存区域

## 1.1 JVM 运行时数据区

![image-20200319191553417](images/image-20200319191553417.png)

### 1.1.1 程序计数器 Program Counter Register

类似于计算机组成原理中的程序计数器 PC。它的作用可以看作是当前线程所执行的字节码的行号指示器。唯一一个不会导致内存泄漏的内存区域。

程序计数器是线程私有的，各个线程之间独立拥有一个程序计数器，互不影响。

### 1.1.2 虚拟机栈 Java Virtual Machine Stacks

线程私有的

会产生```StackOverflowError```和```OutOfMemoryError```错误。

设置JVM参数 **-Xss228k**（栈大小为228k）

### 1.1.3 本地方法栈 Native Method Stacks

会产生```StackOverflowError```和```OutOfMemoryError```错误。

程序计数器、虚拟机栈、本地方法栈随线程而生而灭。

### 1.1.4 堆 Heap

被所有线程所共享的，再虚拟机启动时被创建。

用于存放对象实例。

堆是垃圾收集器管理的主要区域。也被称为 GC 堆。

可以细分为：新生代和老年代。

**-Xms20M  -Xmx20M**（前者表示初始堆大小20M，后者表示最大堆大小20M）

会产生```OutOfMemoryError```错误。

### 1.1.5 方法区 Method Area

被所有线程所共享的。

用于存储：已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等。

别名：Non-Heap

会产生```OutOfMemoryError```错误。

### 1.1.6 运行时常量池

属于方法区的一部分，用于存放：编译期生成的各种字面量和符号引用

会产生```OutOfMemoryError```错误。

## 1.2 对象访问

1. 句柄
   ![image-20200319194643432](images/image-20200319194643432.png)

2. 直接指针

![image-20200319194702842](images/image-20200319194702842.png)



# 2 垃圾回收机制 GC

## 2.1 如何判断对象已死

### 2.1.1 引用计数法 Reference Counting（Java 并不是）

微软的 COM 是

算法：给对象添加一个引用计数器，每次被引用时，计数器自增；当引用失效时，计数器自减。计数器的值为0的对象不能被再次使用。

无法解决：对象之间相互循环引用的问题。

### 2.1.2 根搜索算法 GC Roots Tracing

Java、C#、Lisp 是

算法：通过一系列名为 "GC Roots" 的对象作为起点，开始向下搜索。当从 GC Roots 到一个对象不可达时，则该对象是不可用的。这就解决了对象之间形成闭环的问题。

GC Roots 包括：

1. 虚拟机栈中的引用的对象
2. 本地方法栈中 JNI 的引用的对象
3. 方法区中类静态属性引用的对象
4. 方法区中常量引用的对象

**【我的思考】：那么对于单例对象呢？自身形成闭环怎么处理的。**

答：单例对象由自身类的静态属性所引用。

## 2.2 引用

### 2.2.1 强引用

像 ```Integer i = new Integer()```这种的。

GC 永远也不会回收强引用的对象。

### 2.2.2 软引用

再系统将要内存溢出时，不会马上回收软引用的对象，只会把软引用的对象列入第二次回收的清单当中。如果第一次回收结束后还是没有足够内存，会进行第二次回收，回收软引用对象。

JDK 1.2 之后，使用 ```SoftReference``` 类来实现

### 2.2.3 弱引用

弱引用的对象会在接下来的一次垃圾回收的时候被清理掉。

JDK 1.2 之后，使用 ```WeakReference``` 类来实现

### 2.2.4 虚引用

**虚引用和上述三者不是并列关系**，前三者和对象的生命周期密切相关。而虚引用的目的是为了在这个对象被回收时得到一个系统消息，不会改变对象的生命周期。

JDK 1.2 之后，使用 ```PhantomReference``` 类来实现



## 2.3 GC 是如何回收对象

### 2.3.1 finalize()方法

当一个对象没有重写```finalize()```方法，或者```finalize()```方法已经被执行过一次 都不会执行```finalize()```方法。

任何一个对象的```finalize()```方法都只会被系统自动调用一次，在下一次垃圾回收时```finalize()```方法不会被再次执行。

### 2.3.2 方法区垃圾回收

主要回收：废弃常量 和 无用的类

判断是否为废弃常量：

1. 该类所有的实例都已不存在
2. 加载该类的 ClassLoader 已经被回收
3. 该类对于的 Class 对象没有在任何地方被引用，无法通过反射来访问该类

## 2.4 垃圾收集算法

### 2.4.1 标记 — 清除算法

算法：先标记出需要回收的对象，然后统一回收所有被标记的对象。

缺点：

1. 标记和清除的效率都不高
2. 清除之后会产生大量不连续的内存碎片

### 2.4.2 复制算法

算法：将可用内存分为等量的两块，每次只在其中一块内存上分配对象的空间，另一块内存全部未使用。当第一块内存用完之后，把还需要的对象依次拷贝到第二块内存中，然后把第一块内存全部回收。

解决了：内存碎片的问题

优点：实现简单、运行高效

缺点：将可用内存缩小为了原来的一半

用来回收新生代，将内存分为一块较大的和两块较小的。每次使用一块大的和一块小的，回收时，将需要的对象拷贝到另一块小的上面，清理另外两块。比例默认是 8 : 1 : 1。

### 2.4.3 标记 — 整理算法

算法：先标记出要被回收的对象，然后将所有存活的对象都向堆的一边移动，清理掉边界之外的内存。

**很像数组中删除中间某个元素：后一个元素不断往前拷贝，最后一个元素置为 null。**

### 2.4.4 分代收集算法

算法：将内存分为新生代和老年代。新生代中的对象存活期短，每次标记时会有大量对象死去，采用复制算法清理；老年代对象存活较久，可以使用 标记 — 清除算法 或 标记 — 整理 算法。

## 2.5 垃圾收集器

![image-20200319212916442](images/image-20200319212916442.png)

连线表示两个收集器可以搭配使用。

### 2.5.1 Serial

新生代、单线程 的收集器。在它工作时必须暂停其他线程（Stop The World）。

优点：简单高效

适合：Client 模式下新生代收集器。

![image-20200319213437238](images/image-20200319213437238.png)

### 2.5.2 ParNew

Serial 的多线程版本。也会有 Stop The World。

适合：Server 模式下新生代收集器。

![image-20200319213446924](images/image-20200319213446924.png)

### 2.5.3 Parallel Scavenge

使用复制算法、并行的 多线程、新生代 收集器。

目标：达到一个可控制的吞吐量，吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)。即就是，尽可能缩短垃圾回收的时间。

![image-20200319215013138](images/image-20200319215013138.png)

### 2.5.4 Serial Old

Serial 的老年代版本，单线程，使用 标记 — 整理 法。

适合：Client 模式下老年代收集器，jdk 1.5 以及之前 Server 模式和 Parallel Scavenge 搭配，作为 CMS 的后备。

![image-20200319213437238](images/image-20200319213437238.png)

### 2.5.5 Parallel Old

Parallel Scavenge 的老年代版本，多线程，使用 标记 — 整理 法。

![image-20200319215013138](images/image-20200319215013138.png)

### 2.5.6 CMS

以获得最短回收停顿时间为目标，基于 标记 — 清除 算法。

四个步骤：

1. 初始标记：标记一下 GC Roots 能够直接关联到的对象（速度很快）
2. 并发标记：执行 GC Roots Tracing
3. 重新标记：修正并发标记期间，因用户程序运行而产生的变动（比初始标记稍长，但远短于并发标记的时间）
4. 并发清除

初始标记 和 重新标记 仍然会 Stop The World。

优点：并发收集、低停顿

缺点：

- CMS 对 CPU 资源非常敏感
- 无法处理浮动垃圾
- 使用了 标记 — 清除 算法，会产生大量内存碎片

![image-20200319215720204](images/image-20200319215720204.png)

### 2.5.7 G1

相对CMS的改进：

- 基于 标记 — 整理 算法
- 它可以非常准确地控制停顿

## 2.6 内存分配策略

1. **对象优先分配在新生代**

2. **需要大量连续内存的对象分配到老年代**
3. **长期存活的对象将进入老年代**

当一个对象在新生代每经过一次 GC，年龄加一，当到15岁时进入老年代。

4. **动态年龄判定**

当新生代中相同年龄的对象大小之和大于内存空间一半时，年龄大于或等于该年龄的对象直接进入老年代。

5. **空间分配担保**

![image-20200319221452552](images/image-20200319221452552.png)



# 3 类文件结构

## 3.1 Class 类文件结构

Java 虚拟机具有语言无关性。只要是符合 Java 虚拟机规范的字节码文件，就可以被虚拟机执行。

Java 虚拟机具有平台无关性。不同操作系统上都有相应的虚拟机版本。



1. 魔数：Class 文件前4字节，用来标识 Class 文件。值为，0xCAFEBASE。

2. 版本号：接下来的4字节，第5、6字节是次版本号，第7、8字节是主版本号。
3. 常量池入口：紧后的2字节

常量池中存放：字面量和符号引用；符号引用包括：类和接口的全限定名、字段的名称和描述符

、方法的名称和描述符。