# 2 垃圾回收机制 GC

## 2.1 如何判断对象已死

### 2.1.1 引用计数法 Reference Counting（Java 并不是）

微软的 COM 是

算法：给对象添加一个引用计数器，每次被引用时，计数器自增；当引用失效时，计数器自减。计数器的值为0的对象不能被再次使用。

无法解决：对象之间相互循环引用的问题。

### 2.1.2 根搜索算法 GC Roots Tracing

Java、C#、Lisp 是

算法：通过一系列名为 "GC Roots" 的对象作为起点，开始向下搜索。当从 GC Roots 到一个对象不可达时，则该对象是不可用的。这就解决了对象之间形成闭环的问题。

GC Roots 包括：

1. 虚拟机栈中的引用的对象
2. 本地方法栈中 JNI 的引用的对象
3. 方法区中类静态属性引用的对象
4. 方法区中常量引用的对象

**【我的思考】：那么对于单例对象呢？自身形成闭环怎么处理的。**

答：单例对象由自身类的静态属性所引用。

## 2.2 引用

### 2.2.1 强引用

像 ```Integer i = new Integer()```这种的。

GC 永远也不会回收强引用的对象。

### 2.2.2 软引用

再系统将要内存溢出时，不会马上回收软引用的对象，只会把软引用的对象列入第二次回收的清单当中。如果第一次回收结束后还是没有足够内存，会进行第二次回收，回收软引用对象。

JDK 1.2 之后，使用 ```SoftReference``` 类来实现

### 2.2.3 弱引用

弱引用的对象会在接下来的一次垃圾回收的时候被清理掉。

JDK 1.2 之后，使用 ```WeakReference``` 类来实现

### 2.2.4 虚引用

**虚引用和上述三者不是并列关系**，前三者和对象的生命周期密切相关。而虚引用的目的是为了在这个对象被回收时得到一个系统消息，不会改变对象的生命周期。

JDK 1.2 之后，使用 ```PhantomReference``` 类来实现



## 2.3 GC 是如何回收对象

### 2.3.1 ```finalize()```方法

当一个对象没有重写```finalize()```方法，或者```finalize()```方法已经被执行过一次 都不会执行```finalize()```方法。

任何一个对象的```finalize()```方法都只会被系统自动调用一次，在下一次垃圾回收时```finalize()```方法不会被再次执行。

### 2.3.2 方法区垃圾回收

主要回收：废弃常量 和 无用的类

判断是否为废弃常量：

1. 该类所有的实例都已不存在
2. 加载该类的 ClassLoader 已经被回收
3. 该类对于的 Class 对象没有在任何地方被引用，无法通过反射来访问该类

## 2.4 垃圾收集算法

### 2.4.1 标记 — 清除算法

算法：先标记出需要回收的对象，然后统一回收所有被标记的对象。

缺点：

1. 标记和清除的效率都不高
2. 清除之后会产生大量不连续的内存碎片

### 2.4.2 复制算法

算法：将可用内存分为等量的两块，每次只在其中一块内存上分配对象的空间，另一块内存全部未使用。当第一块内存用完之后，把还需要的对象依次拷贝到第二块内存中，然后把第一块内存全部回收。

解决了：内存碎片的问题

优点：实现简单、运行高效

缺点：将可用内存缩小为了原来的一半

用来回收新生代，将内存分为一块较大的和两块较小的。每次使用一块大的和一块小的，回收时，将需要的对象拷贝到另一块小的上面，清理另外两块。比例默认是 8 : 1 : 1。

### 2.4.3 标记 — 整理算法

算法：先标记出要被回收的对象，然后将所有存活的对象都向堆的一边移动，清理掉边界之外的内存。

**很像数组中删除中间某个元素：后一个元素不断往前拷贝，最后一个元素置为 null。**

### 2.4.4 分代收集算法

算法：将内存分为新生代和老年代。新生代中的对象存活期短，每次标记时会有大量对象死去，采用复制算法清理；老年代对象存活较久，可以使用 标记 — 清除算法 或 标记 — 整理 算法。

## 2.5 垃圾收集器

![image-20200319212916442](images/image-20200319212916442.png)

连线表示两个收集器可以搭配使用。

### 2.5.1 Serial

新生代、单线程 的收集器。在它工作时必须暂停其他线程（Stop The World）。

优点：简单高效

适合：Client 模式下新生代收集器。

![image-20200319213437238](images/image-20200319213437238.png)

### 2.5.2 ParNew

Serial 的多线程版本。也会有 Stop The World。

适合：Server 模式下新生代收集器。

![image-20200319213446924](images/image-20200319213446924.png)

### 2.5.3 Parallel Scavenge

使用复制算法、并行的 多线程、新生代 收集器。

目标：达到一个可控制的吞吐量，吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)。即就是，尽可能缩短垃圾回收的时间。

![image-20200319215013138](images/image-20200319215013138.png)

### 2.5.4 Serial Old

Serial 的老年代版本，单线程，使用 标记 — 整理 法。

适合：Client 模式下老年代收集器，jdk 1.5 以及之前 Server 模式和 Parallel Scavenge 搭配，作为 CMS 的后备。

![image-20200319213437238](images/image-20200319213437238.png)

### 2.5.5 Parallel Old

Parallel Scavenge 的老年代版本，多线程，使用 标记 — 整理 法。

![image-20200319215013138](images/image-20200319215013138.png)

### 2.5.6 CMS

以获得最短回收停顿时间为目标，基于 标记 — 清除 算法。

四个步骤：

1. 初始标记：标记一下 GC Roots 能够直接关联到的对象（速度很快）
2. 并发标记：执行 GC Roots Tracing
3. 重新标记：修正并发标记期间，因用户程序运行而产生的变动（比初始标记稍长，但远短于并发标记的时间）
4. 并发清除

初始标记 和 重新标记 仍然会 Stop The World。

优点：并发收集、低停顿

缺点：

- CMS 对 CPU 资源非常敏感
- 无法处理浮动垃圾
- 使用了 标记 — 清除 算法，会产生大量内存碎片

![image-20200319215720204](images/image-20200319215720204.png)

### 2.5.7 G1

相对CMS的改进：

- 基于 标记 — 整理 算法
- 它可以非常准确地控制停顿

## 2.6 内存分配策略

1. **对象优先分配在新生代**

2. **需要大量连续内存的对象分配到老年代**
3. **长期存活的对象将进入老年代**

当一个对象在新生代每经过一次 GC，年龄加一，当到15岁时进入老年代。

4. **动态年龄判定**

当新生代中相同年龄的对象大小之和大于内存空间一半时，年龄大于或等于该年龄的对象直接进入老年代。

5. **空间分配担保**

![image-20200319221452552](images/image-20200319221452552.png)